from __future__ import annotations

import warnings
from collections.abc import Iterable
from typing import Any, TypeAlias

import marker
import marker.converters
import marker.models

from sieves.data.doc import Doc
from sieves.serialization import Config
from sieves.tasks.core import Task
from sieves.tasks.preprocessing import docling_, marker_

Model: TypeAlias = docling_.Model | marker_.Model


class OCR(Task):
    """
    Base class for OCR tasks that extract text from documents.
    This unified interface allows different OCR models to be used interchangeably.
    """

    def __init__(
        self,
        model: Model = marker.converters.pdf.PdfConverter(artifact_dict=marker.models.create_model_dict()),
        task_id: str | None = "OCR",
        show_progress: bool = True,
        include_meta: bool = False,
        **kwargs: Any,
    ):
        """
        Initialize the OCR task.
        :param model: The OCR model to use.
        :param task_id: Task ID.
        :param show_progress: Whether to show progress bar for processed documents.
        :param include_meta: Whether to include meta information generated by the task.
        :param kwargs: Additional arguments for specific OCR implementations.
        """
        super().__init__(task_id=task_id, show_progress=show_progress, include_meta=include_meta)
        self._model = model
        self._show_progress = show_progress
        self._include_meta = include_meta
        self._kwargs = kwargs

        print(self._kwargs)
        self._task = self._init_ocr_task()

    def _init_ocr_task(self) -> Model:
        """
        Initialize the bridge for the specific OCR implementation.
        :return: OCR bridge implementation.
        """
        model_type = type(self._model)
        module_task_map = {marker_: marker_.Marker, docling_: docling_.Docling}
        for module, task_type in module_task_map.items():
            try:
                module_model_types = module.Model.__args__
            except AttributeError:
                module_model_types = (module.Model,)
            if any(model_type == module_model_type for module_model_type in module_model_types):
                ocr_task = task_type(
                    model=self._model,
                    task_id=self.id,
                    show_progress=self._show_progress,
                    include_meta=self._include_meta,
                    **self._kwargs,
                )
                assert isinstance(ocr_task, Task)
                return ocr_task
        else:
            raise ValueError(
                f"Model type {self._model} is not supported. Please check the documentation and ensure you're "
                f"providing a supported model type."
            )

    def __call__(self, docs: Iterable[Doc]) -> Iterable[Doc]:
        """
        Process documents with OCR to extract text.
        :param docs: Documents to process.
        :return: Processed documents with extracted text.
        """
        docs = list(docs)
        result: Iterable[Doc] = []
        # Validate docs
        for doc in docs:
            assert doc.uri, ValueError("Documents have to have a value for .uri.")
        try:
            result = self._task(docs)
            return result
        except Exception as e:
            warnings.warn(f"Failed to process document {doc.uri}: {str(e)}")
            return docs

    @property
    def _state(self) -> dict[str, Any]:
        """
        Returns attributes to serialize.
        :return: Dict of attributes to serialize.
        """
        return {
            **super()._state,
            "model": self._model,
            **self._kwargs,
        }

    @classmethod
    def deserialize(cls, config: Config, **kwargs: dict[str, Any]) -> OCR:
        """
        Generate OCR instance from config.
        :param config: Config to generate instance from.
        :param kwargs: Values to inject into loaded config.
        :return: Deserialized OCR instance.
        """
        return cls(**config.to_init_dict(cls, **kwargs))
