from __future__ import annotations

import warnings
from collections.abc import Iterable
from typing import Any, Literal

import docling.document_converter
import unstructured.partition.auto
from tqdm import tqdm

from sieves.data.doc import Doc
from sieves.serialization import Config
from sieves.tasks.core import Task
from sieves.tasks.preprocessing.ocr.bridges import DoclingBridge, OCRBridge, UnstructuredBridge


class OCR(Task):
    """
    Base class for OCR tasks that extract text from documents.
    This unified interface allows different OCR engines to be used interchangeably.
    """

    def __init__(
        self,
        backend: Literal["unstructured", "docling", "marker"] = "docling",
        task_id: str | None = None,
        show_progress: bool = True,
        include_meta: bool = False,
        **kwargs: Any,
    ):
        """
        Initialize the OCR task.
        :param backend: The OCR backend to use (Supported: 'unstructured', 'docling').
        :param task_id: Task ID.
        :param show_progress: Whether to show progress bar for processed documents.
        :param include_meta: Whether to include meta information generated by the task.
        :param kwargs: Additional arguments for specific OCR implementations.
        """
        super().__init__(task_id=task_id, show_progress=show_progress, include_meta=include_meta)
        self._backend = backend
        self._kwargs = kwargs
        self._bridge = self._init_bridge()

    def _init_bridge(self) -> OCRBridge:
        """
        Initialize the bridge for the specific OCR implementation.
        :return: OCR bridge implementation.
        """

        if self._backend == "unstructured":
            partition = self._kwargs.get("partition", unstructured.partition.auto.partition)
            cleaners = self._kwargs.get("cleaners", ())

            # Remove parameters already consumed
            partition_kwargs = {k: v for k, v in self._kwargs.items() if k not in ["partition", "cleaners"]}

            return UnstructuredBridge(task_id=self.id, partition=partition, cleaners=cleaners, **partition_kwargs)

        elif self._backend == "docling":
            doc_converter = self._kwargs.get("doc_converter")
            if doc_converter is None:
                doc_converter = docling.document_converter.DocumentConverter()

            return DoclingBridge(task_id=self.id, doc_converter=doc_converter)

        else:
            raise ValueError(f"Unknown backend: {self._backend}. Supported backends are 'unstructured' and 'docling'.")

    def __call__(self, docs: Iterable[Doc]) -> Iterable[Doc]:
        """
        Process documents with OCR to extract text.
        :param docs: Documents to process.
        :return: Processed documents with extracted text.
        """
        docs = list(docs)

        # Validate docs
        for doc in docs:
            assert doc.uri, ValueError("Documents have to have a value for .uri.")

        # Use progress bar if requested
        iterable = tqdm(docs, total=len(docs)) if self._show_progress else docs

        for doc in iterable:
            try:
                result = self._bridge.process(doc)

                # Set the extracted text
                doc.text = result.text

                # Include metadata if requested
                if self._include_meta and result.metadata:
                    doc.meta |= {self.id: result.metadata}

                # Set chunks if available
                if result.chunks:
                    doc.chunks = result.chunks

            except Exception as e:
                # Log but continue processing other docs
                warnings.warn(f"Failed to process document {doc.uri}: {str(e)}")

        return docs

    @property
    def _state(self) -> dict[str, Any]:
        """
        Returns attributes to serialize.
        :return: Dict of attributes to serialize.
        """
        return {
            **super()._state,
            "backend": self._backend,
            **self._kwargs,
        }

    @classmethod
    def deserialize(cls, config: Config, **kwargs: dict[str, Any]) -> OCR:
        """
        Generate OCR instance from config.
        :param config: Config to generate instance from.
        :param kwargs: Values to inject into loaded config.
        :return: Deserialized OCR instance.
        """
        return cls(**config.to_init_dict(cls, **kwargs))
