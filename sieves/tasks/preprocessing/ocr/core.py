from __future__ import annotations

import warnings
from collections.abc import Iterable
from typing import Any, TypeAlias

import docling.document_converter
from marker.converters.pdf import PdfConverter
from marker.converters.table import TableConverter

from sieves.data.doc import Doc
from sieves.serialization import Config
from sieves.tasks.core import Task
from sieves.tasks.preprocessing import docling_, marker_

Converter: TypeAlias = docling.document_converter.DocumentConverter | PdfConverter | TableConverter


class OCR(Task):
    """
    Base class for OCR tasks that extract text from documents.
    This unified interface allows different OCR converters to be used interchangeably.
    """

    def __init__(
        self,
        converter: Converter = docling.document_converter.DocumentConverter,
        task_id: str | None = None,
        show_progress: bool = True,
        include_meta: bool = False,
        **kwargs: Any,
    ):
        """
        Initialize the OCR task.
        :param converter: The OCR converter to use.
        :param task_id: Task ID.
        :param show_progress: Whether to show progress bar for processed documents.
        :param include_meta: Whether to include meta information generated by the task.
        :param kwargs: Additional arguments for specific OCR implementations.
        """
        super().__init__(task_id=task_id, show_progress=show_progress, include_meta=include_meta)
        self._converter = converter

        print(self._kwargs)
        self._task = self._init_ocr_task()

    def _init_ocr_task(self) -> Converter:
        """
        Initialize the bridge for the specific OCR implementation.
        :return: OCR bridge implementation.
        """
        converter_type = type(self._converter)
        module_task_map = {marker_: marker_.Marker, docling_: docling_.Docling}
        for module, task_type in module_task_map.items():
            try:
                module_converter_types = module.Converter.__args__
            except AttributeError:
                module_converter_types = (module.Converter,)
            if any(converter_type == module_converter_type for module_converter_type in module_converter_types):
                ocr_task = task_type(
                    converter=self._converter,
                    task_id=self.id,
                    show_progress=self._show_progress,
                    include_meta=self._include_meta,
                    **self._kwargs,
                )
                assert isinstance(ocr_task, Task)
                return ocr_task
        else:
            raise ValueError(
                f"converter type {self._converter} is not supported. Please check the documentation and ensure you're "
                f"providing a supported converter type."
            )

    def __call__(self, docs: Iterable[Doc]) -> Iterable[Doc]:
        """
        Process documents with OCR to extract text.
        :param docs: Documents to process.
        :return: Processed documents with extracted text.
        """
        docs = list(docs)
        result: Iterable[Doc] = []
        # Validate docs
        assert all(doc.uri for doc in docs), ValueError("Documents have to have a value for .uri.")
        result = self._task(docs)

        yield from result

    @property
    def _state(self) -> dict[str, Any]:
        """
        Returns attributes to serialize.
        :return: Dict of attributes to serialize.
        """
        return {
            **super()._state,
            "converter": self._converter,
            **self._kwargs,
        }

    @classmethod
    def deserialize(cls, config: Config, **kwargs: dict[str, Any]) -> OCR:
        """
        Generate OCR instance from config.
        :param config: Config to generate instance from.
        :param kwargs: Values to inject into loaded config.
        :return: Deserialized OCR instance.
        """
        return cls(**config.to_init_dict(cls, **kwargs))
