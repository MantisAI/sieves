from __future__ import annotations

from collections.abc import Iterable
from typing import Any, TypeAlias

import datasets
import pydantic

from sieves.data import Doc
from sieves.engines import Engine, EngineType, dspy_, glix_, huggingface_, instructor_, langchain_, ollama_, outlines_
from sieves.engines.core import EngineInferenceMode, EngineModel, EnginePromptSignature, EngineResult
from sieves.serialization import Config

from sieves.tasks.predictive.ner.bridges import (
    DSPyNER,
    InstructorNER,
    LangChainNER,
    OllamaNER,
    OutlinesNER,
    # GliXNER,
)
from sieves.tasks.predictive.core import PredictiveTask

_TaskPromptSignature: TypeAlias = None
_TaskResult: TypeAlias = list[tuple[str, int, int]] | list[tuple[str, str, int, int]] | pydantic.BaseModel | dspy_.Result | glix_.Result | huggingface_.Result | instructor_.Result | langchain_.Result | ollama_.Result | outlines_.Result
_TaskBridge: TypeAlias = (
    None
)

# class TaskFewshotExample(pydantic.BaseModel):
#     text: str
#     entities: tuple[tuple[str, int, int], ...]


class NER(PredictiveTask[_TaskPromptSignature, _TaskResult, _TaskBridge]):
    def __init__(
            self,
            entities: list[str],
            engine: Engine[EnginePromptSignature, EngineResult, EngineModel, EngineInferenceMode],
            task_id: str | None = None,
            show_progress: bool = True,
            include_meta: bool = True,
            prompt_template: str | None = None,
            prompt_signature_desc: str | None = None,
            # fewshot_examples: Iterable[TaskFewshotExample] = (),
    ) -> None:
        """"
        Initializes new PredictiveTask.
        :param task_id: Task ID.
        :param show_progress: Whether to show progress bar for processed documents.
        :param include_meta: Whether to include meta information generated by the task.
        :param prompt_template: Custom prompt template. If None, task's default template is being used.
        :param prompt_signature_desc: Custom prompt signature description. If None, default will be used.
        :param fewshot_examples: Few-shot examples.
        """
        self._entities = entities or ["PERSON", "LOCATION", "ORGANIZATION"]
        super().__init__(
            engine=engine,
            task_id=task_id,
            show_progress=show_progress,
            include_meta=include_meta,
            overwrite=False,
            prompt_template=prompt_template,
            prompt_signature_desc=prompt_signature_desc,
            # fewshot_examples=fewshot_examples,
            fewshot_examples=None,
        ) 
        # self._fewshot_examples: Iterable[TaskFewshotExample]

    def _init_bridge(self, engine_type: EngineType) -> _TaskBridge:
        """Initialize bridge.
        :return: Engine task.
        :raises ValueError: If engine type is not supported.
        """
        bridge_types: dict[EngineType, type[_TaskBridge]] = {
            EngineType.langchain: LangChainNER,
            EngineType.ollama: OllamaNER,
            EngineType.outlines: OutlinesNER,
            EngineType.dspy: DSPyNER,
            EngineType.instructor: InstructorNER,
            # EngineType.glix: GliXNER,
        }
        try:
            bridge_type = bridge_types[engine_type](
                task_id=self._task_id,
                prompt_template=self._custom_prompt_template,
                prompt_signature_desc=self._custom_prompt_signature_desc,
                entities=self._entities,
            )
        except KeyError as err:
            raise KeyError(f"Engine type {engine_type} is not supported by {self.__class__.__name__}.") from err

        return bridge_type

    @property
    def supports(self) -> set[EngineType]:
        return {
            EngineType.langchain,
            EngineType.ollama,
            EngineType.dspy,
            EngineType.outlines,
            EngineType.instructor,
            # EngineType.glix,
        }
    

    @property
    def _state(self) -> dict[str, Any]:
        return {
            **super()._state,
            "entities": self._entities,
        }
    
    # def _validate_fewshot_examples(self) -> None:
    #     for fs_example in self._fewshot_examples or []:
    #         if any([entity not in self._entities for entity in fs_example.entities]) or not all(
    #             [entity in fs_example.entities for entity in self._entities]
    #         ):
    #             raise ValueError(f"Entity mismatch: {self._task_id} has entities {self._entities}. Few-shot examples has entities {fs_example.entities}.")
    
    def to_dataset(self, docs: Iterable[Doc]) -> datasets.Dataset:
        return None