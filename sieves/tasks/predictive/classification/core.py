from typing import TypeAlias

from tasks.predictive.classification.engine_tasks import (
    DSPyClassification,
    GliXClassification,
    HuggingFaceClassification,
    OutlinesClassification,
)

from sieves.engines import Engine, EngineType, dspy_, glix_, huggingface_, outlines_
from sieves.engines.core import InferenceMode, Model, PromptSignature, Result
from sieves.tasks.core import EnginePredictiveTask, PredictiveTask

TaskPromptSignature: TypeAlias = list[str] | dspy_.PromptSignature
TaskInferenceMode: TypeAlias = (
    outlines_.InferenceMode | dspy_.InferenceMode | huggingface_.InferenceMode | glix_.InferenceMode
)
TaskResult: TypeAlias = outlines_.Result | dspy_.Result | huggingface_.Result | glix_.Result


class Classification(PredictiveTask[TaskPromptSignature, TaskResult, Model, TaskInferenceMode]):
    def __init__(
        self,
        labels: list[str],
        engine: Engine[PromptSignature, Result, Model, InferenceMode],
        task_id: str | None = None,
        show_progress: bool = True,
        include_meta: bool = True,
    ) -> None:
        """
        Initializes new PredictiveTask.
        :param labels: Labels to predict.
        :param task_id: Task ID.
        :param show_progress: Whether to show progress bar for processed documents.
        :param include_meta: Whether to include meta information generated by the task.
        """
        self._labels = labels
        super().__init__(engine=engine, task_id=task_id, show_progress=show_progress, include_meta=include_meta)

    def _init_engine_task(
        self, engine_type: EngineType
    ) -> EnginePredictiveTask[TaskPromptSignature, TaskInferenceMode, TaskResult]:
        """Initialize engine task.
        :returns: Engine task.
        :raises ValueError: If engine type is not supported.
        """
        match engine_type:
            case EngineType.dspy:
                engine_task = DSPyClassification(self._task_id, self._labels)
            case EngineType.glix:
                engine_task = GliXClassification(self._task_id, self._labels)
            case EngineType.huggingface:
                engine_task = HuggingFaceClassification(self._task_id, self._labels)
            case EngineType.outlines:
                engine_task = OutlinesClassification(self._task_id, self._labels)
            case _:
                raise ValueError(f"Unsupported engine type: {engine_type}")

        assert isinstance(engine_task, EnginePredictiveTask)
        return engine_task

    @property
    def supports(self) -> set[EngineType]:
        return {EngineType.outlines, EngineType.dspy, EngineType.huggingface}
